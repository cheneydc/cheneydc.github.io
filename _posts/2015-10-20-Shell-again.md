---
layout: post
title: Shell--再来一遍-3
category: 技术 
published: true
---

# 引用

说实话这个部分是我最迷惑的，看来还是用的少啊。但是既然是引用，也就表示是特殊的，和不引用的不一样，搞清楚不一样的地方应该就好多了，下面看看具体情况。

## 引用变量

一般使用变量都是$开头的，当使用双引号的时候是会展开的，而单引号则只表示字面，不展开变量的值。为了怕记错我只记住一个，双引号展开变量，双引号展开变量，双引号展开变量……重要的事情说三遍！！！

当然也有奇怪的事情发生，看看这个例子：

```bash
root@host-192-168-99-29:~# IFS='\'
root@host-192-168-99-29:~# var='"{}\\sdf"'
root@host-192-168-99-29:~# echo $var
"{}  sdf"
root@host-192-168-99-29:~# echo "$var"
"{}\\sdf"
root@host-192-168-99-29:~# echo $IFS

root@host-192-168-99-29:~# echo "$IFS"
\
```

这里有一个`IFS`，它是(Internal Field Seprator)的缩写，是内部域分隔符，前面知道shell中有set和env两种变量，实际上两种变量的作用域不同，evn是当前用户的。那么IFS就是set的一个变量，shell中执行指令的时候，是通过IFS来对字串进行分隔拆解的。
当变量不引用的时候shell通过IFS对变量的输出进行了拆解，由于我们将IFS赋值成了`\`，所以变量输出的时候`\`没有显示；而通过`""`引用变量的时候，IFS被展开成了自己实际的字符，所以就能完整显示了。

# 退出和退出状态

exit命令用来结束一个脚本，同时返回一个值给父进程。
通常一个执行成功的脚本返回0，非零值（0~255）都视为执行失败。

脚本里的函数和脚本自身都有一个退出状态码。脚本或者函数中被执行的最后一个命令决定退出状态码。

如果一个脚本执行exit没有带参数，则脚本的退出状态码就是脚本最后执行的命令的退出码。

脚本结束没有exit，不带参数的exit和exit $?是一样的效果。

因为$?保存了上一条命令执行的状态码。
